(self.webpackChunkagile_docs=self.webpackChunkagile_docs||[]).push([[1917],{3905:function(e,t,n){"use strict";n.d(t,{Zo:function(){return s},kt:function(){return k}});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function l(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?l(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):l(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},l=Object.keys(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var p=a.createContext({}),d=function(e){var t=a.useContext(p),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},s=function(e){var t=d(e.components);return a.createElement(p.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,l=e.originalType,p=e.parentName,s=o(e,["components","mdxType","originalType","parentName"]),m=d(n),k=r,c=m["".concat(p,".").concat(k)]||m[k]||u[k]||l;return n?a.createElement(c,i(i({ref:t},s),{},{components:n})):a.createElement(c,i({ref:t},s))}));function k(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var l=n.length,i=new Array(l);i[0]=m;var o={};for(var p in t)hasOwnProperty.call(t,p)&&(o[p]=t[p]);o.originalType=e,o.mdxType="string"==typeof e?e:r,i[1]=o;for(var d=2;d<l;d++)i[d]=n[d];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},5318:function(e,t,n){"use strict";n.r(t),n.d(t,{frontMatter:function(){return i},metadata:function(){return o},toc:function(){return p},default:function(){return s}});var a=n(2122),r=n(9756),l=(n(7294),n(3905)),i={id:"interfaces",title:"Interfaces",sidebar_label:"Interfaces",slug:"/interfaces"},o={unversionedId:"interfaces",id:"interfaces",isDocsHomePage:!1,title:"Interfaces",description:"This Section might be useless to you without any context.",source:"@site/docs/Interfaces.md",sourceDirName:".",slug:"/interfaces",permalink:"/test/docs/interfaces",editUrl:"https://github.com/agile-ts/documentation/tree/develop/docs/Interfaces.md",version:"current",lastUpdatedAt:1620882043,formattedLastUpdatedAt:"5/13/2021",sidebar_label:"Interfaces",frontMatter:{id:"interfaces",title:"Interfaces",sidebar_label:"Interfaces",slug:"/interfaces"},sidebar:"docs",previous:{title:"Vue Examples",permalink:"/test/docs/examples/vue"}},p=[{value:"<code>CreateLoggerConfig</code>",id:"createloggerconfig",children:[]},{value:"<code>StateIngestConfig</code>",id:"stateingestconfig",children:[]},{value:"<code>StateRuntimeJobConfig</code>",id:"stateruntimejobconfig",children:[]},{value:"<code>RuntimeJobConfigInterface</code>",id:"runtimejobconfiginterface",children:[]},{value:"<code>IngestConfigInterface</code>",id:"ingestconfiginterface",children:[]},{value:"<code>PatchConfig</code>",id:"patchconfig",children:[]},{value:"<code>StatePersistentConfig</code>",id:"statepersistentconfig",children:[]},{value:"<code>GroupConfig</code>",id:"groupconfig",children:[]},{value:"<code>SelectorConfig</code>",id:"selectorconfig",children:[]},{value:"<code>CollectConfig</code>",id:"collectconfig",children:[]},{value:"<code>UpdateConfig</code>",id:"updateconfig",children:[]},{value:"<code>HasConfig</code>",id:"hasconfig",children:[]},{value:"<code>AddSideEffectConfig</code>",id:"addsideeffectconfig",children:[]},{value:"<code>GroupAddConfig</code>",id:"groupaddconfig",children:[]},{value:"<code>UpdateItemKeyConfig</code>",id:"updateitemkeyconfig",children:[]},{value:"<code>ComputeConfig</code>",id:"computeconfig",children:[]},{value:"<code>RecomputeConfig</code>",id:"recomputeconfig",children:[]},{value:"<code>UpdateComputeFunctionConfig</code>",id:"updatecomputefunctionconfig",children:[]},{value:"<code>AgileHookConfigInterface</code>",id:"agilehookconfiginterface",children:[]},{value:"<code>ProxyHookConfigInterface</code>",id:"proxyhookconfiginterface",children:[]}],d={toc:p};function s(e){var t=e.components,i=(0,r.Z)(e,["components"]);return(0,l.kt)("wrapper",(0,a.Z)({},d,i,{components:t,mdxType:"MDXLayout"}),(0,l.kt)("div",{className:"admonition admonition-info alert alert--info"},(0,l.kt)("div",{parentName:"div",className:"admonition-heading"},(0,l.kt)("h5",{parentName:"div"},(0,l.kt)("span",{parentName:"h5",className:"admonition-icon"},"\u2757\ufe0f"),"info")),(0,l.kt)("div",{parentName:"div",className:"admonition-content"},(0,l.kt)("p",{parentName:"div"},(0,l.kt)("strong",{parentName:"p"},"This Section might be useless to you without any context."),"\nAs the name suggests, it's all about typescript interfaces of AgileTs.\nThese interfaces are outsourced for a better overview, maintainability, and reusability.\nYou might get redirected to parts of the Interface Section from other documentation to learn more about specific Interfaces."))),(0,l.kt)("h2",{id:"createloggerconfig"},(0,l.kt)("inlineCode",{parentName:"h2"},"CreateLoggerConfig")),(0,l.kt)("p",null,"The ",(0,l.kt)("inlineCode",{parentName:"p"},"CreateLoggerConfigInterface")," is used in the creation and configuration of the ",(0,l.kt)("a",{parentName:"p",href:"/test/docs/core/agile-instance/properties#logger"},"Agile ",(0,l.kt)("inlineCode",{parentName:"a"},"Logger Class")),".\nHere is a Typescript Interface for quick reference. However,\neach property is explained in more detail below."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-ts"},"export interface CreateLoggerConfigInterface {\n    prefix?: string;\n    allowedTags?: string[];\n    canUseCustomStyles?: boolean;\n    active?: boolean;\n    level?: number;\n    timestamp?: boolean;\n}\n")),(0,l.kt)("br",null),(0,l.kt)("h4",{id:"prefix"},(0,l.kt)("inlineCode",{parentName:"h4"},"prefix")),(0,l.kt)("p",null,"Prefix which is added before each log message."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-ts",metastring:"{2}","{2}":!0},'const logger = new Logger({\n    prefix: "MyLog"\n});\n\nlogger.debug("Jeff"); // Logs \'MyLog Debug: Jeff\'\n')),(0,l.kt)("p",null,'The log messages of AgileTs have the default prefix "Agile".'),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Default"),(0,l.kt)("th",{parentName:"tr",align:null},"Required"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"string")),(0,l.kt)("td",{parentName:"tr",align:null},'"Agile"'),(0,l.kt)("td",{parentName:"tr",align:null},"No")))),(0,l.kt)("br",null),(0,l.kt)("h4",{id:"level"},(0,l.kt)("inlineCode",{parentName:"h4"},"level")),(0,l.kt)("p",null,"The ",(0,l.kt)("inlineCode",{parentName:"p"},"log level")," controls which kind of log messages are allowed to be logged.\nTherefore, it is used to filter log messages to only see these relevant to us.\nFor example, we won't often set the ",(0,l.kt)("inlineCode",{parentName:"p"},"log level")," to ",(0,l.kt)("inlineCode",{parentName:"p"},"debug"),"\nsince debug messages flood the console and are, in most cases, not relevant for us."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-ts",metastring:"{2}","{2}":!0},'const logger = new Logger({\n    level: Logger.level.WARN\n});\n\nlogger.debug("Jeff"); // Doesn\'t get logged\nlogger.warn("A important Warning"); // Gets logged\n')),(0,l.kt)("p",null,"The ",(0,l.kt)("inlineCode",{parentName:"p"},"Logger Class")," supports some hard-coded log levels, which can be set dynamically."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-ts"},"{\n    TRACE: 1,\n    DEBUG: 2,\n    LOG: 5,\n    TABLE: 5,\n    INFO: 10,\n    SUCCESS: 15,\n    WARN: 20,\n    ERROR: 50,\n}\n\nLogger.level.LOG; // 5\n")),(0,l.kt)("p",null,"For example, suppose we set the logger level to ",(0,l.kt)("inlineCode",{parentName:"p"},"INFO"),". In that case,\neach log category at a higher or same level is printed to the console.\nIn the case of ",(0,l.kt)("inlineCode",{parentName:"p"},"INFO"),", that would be ",(0,l.kt)("inlineCode",{parentName:"p"},"SUCCESS"),", ",(0,l.kt)("inlineCode",{parentName:"p"},"WARN"),", ",(0,l.kt)("inlineCode",{parentName:"p"},"ERROR")," and of course ",(0,l.kt)("inlineCode",{parentName:"p"},"INFO"),"."),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Default"),(0,l.kt)("th",{parentName:"tr",align:null},"Required"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"number")),(0,l.kt)("td",{parentName:"tr",align:null},"20"),(0,l.kt)("td",{parentName:"tr",align:null},"No")))),(0,l.kt)("br",null),(0,l.kt)("h4",{id:"active"},(0,l.kt)("inlineCode",{parentName:"h4"},"active")),(0,l.kt)("p",null,"Determines whether the logger is ",(0,l.kt)("inlineCode",{parentName:"p"},"active")," and is allowed to print messages to the console."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-ts",metastring:"{2}","{2}":!0},'const logger = new Logger({\n    active: false\n});\n\nlogger.log("Jeff"); // Doesn\'t get logged\nlogger.isActive = true;\nlogger.log("Jeff"); // Gets logged\n')),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Default"),(0,l.kt)("th",{parentName:"tr",align:null},"Required"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"boolean")),(0,l.kt)("td",{parentName:"tr",align:null},"true"),(0,l.kt)("td",{parentName:"tr",align:null},"No")))),(0,l.kt)("br",null),(0,l.kt)("h4",{id:"timestamp"},(0,l.kt)("inlineCode",{parentName:"h4"},"timestamp")),(0,l.kt)("p",null,"If ",(0,l.kt)("inlineCode",{parentName:"p"},"true"),", a timestamp is added before each log message.\nThis timestamp represents the time the message was logged."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-ts",metastring:"{2}","{2}":!0},"const logger = new Logger({\n    timestamp: true\n});\n\nlogger.debug(\"Jeff\"); // Logs '[1613108673781] Debug: Jeff'\n")),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Default"),(0,l.kt)("th",{parentName:"tr",align:null},"Required"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"boolean")),(0,l.kt)("td",{parentName:"tr",align:null},"false"),(0,l.kt)("td",{parentName:"tr",align:null},"No")))),(0,l.kt)("br",null),(0,l.kt)("h4",{id:"allowedtags"},(0,l.kt)("inlineCode",{parentName:"h4"},"allowedTags")),(0,l.kt)("p",null,"Sometimes logging can be very confusing and overwhelming if the console is flooded with logs that don't matter at the time.\nTherefore, ",(0,l.kt)("inlineCode",{parentName:"p"},"tags")," got created which filter logs specifically by tags."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-ts",metastring:"{2}","{2}":!0},'const logger = new Logger({\n    allowedTags: ["jeff", "hans"]\n});\n\nlogger.debug("Jeff"); // Gets logged\nlogger.if.tag(["jeff"]).debug("Jeff"); // Doesn\'t get logged\nlogger.if.tag(["hans", "jeff"]).debug("Jeff");; // Gets get logged\nlogger.if.tag(["hans"]).debug("Jeff");; // Doesn\'t get logged\nlogger.if.tag(["hans", "frank"]).debug("Jeff");; // Doesn\'t get logged\n')),(0,l.kt)("p",null,"Any log message with defined tags will only be logged if all its tags are allowed in the ",(0,l.kt)("inlineCode",{parentName:"p"},"Logger Class"),".\nLogs that have no condition/tag are always logged."),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Default"),(0,l.kt)("th",{parentName:"tr",align:null},"Required"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"string[]")),(0,l.kt)("td",{parentName:"tr",align:null},"['runtime', 'storage', 'subscription', 'multieditor']"),(0,l.kt)("td",{parentName:"tr",align:null},"No")))),(0,l.kt)("br",null),(0,l.kt)("h4",{id:"canusecustomstyles"},(0,l.kt)("inlineCode",{parentName:"h4"},"canUseCustomStyles")),(0,l.kt)("p",null,"Whether we can apply custom ",(0,l.kt)("inlineCode",{parentName:"p"},"css")," styles to the log messages."),(0,l.kt)("p",null,(0,l.kt)("img",{alt:"Log Custom Styles Example",src:n(317).Z})),(0,l.kt)("p",null,"For example, AgileTs Logs are by default purple."),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Default"),(0,l.kt)("th",{parentName:"tr",align:null},"Required"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"boolean")),(0,l.kt)("td",{parentName:"tr",align:null},"true"),(0,l.kt)("td",{parentName:"tr",align:null},"No")))),(0,l.kt)("br",null),(0,l.kt)("hr",null),(0,l.kt)("br",null),(0,l.kt)("h2",{id:"stateingestconfig"},(0,l.kt)("inlineCode",{parentName:"h2"},"StateIngestConfig")),(0,l.kt)("p",null,"The ",(0,l.kt)("inlineCode",{parentName:"p"},"StateIngestConfigInterface")," is used as configuration object in functions like ",(0,l.kt)("a",{parentName:"p",href:"/test/docs/core/state/methods#set"},(0,l.kt)("inlineCode",{parentName:"a"},"set()"))," or ",(0,l.kt)("a",{parentName:"p",href:"/test/docs/core/state/methods#undo"},(0,l.kt)("inlineCode",{parentName:"a"},"undo()")),".\nHere is a Typescript Interface for quick reference. However,\neach property is explained in more detail below."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-ts"},"export interface StateIngestConfigInterface\n        extends StateRuntimeJobConfigInterface,\n                IngestConfigInterface {\n   key?: RuntimeJobKey;\n}\n")),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Note:")," The ",(0,l.kt)("inlineCode",{parentName:"p"},"StateIngestConfigInterface")," extends some other Interfaces:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("a",{parentName:"li",href:"#stateruntimejobconfig"},"StateRuntimeJobConfigInterface")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("a",{parentName:"li",href:"#ingestconfiginterface"},"IngestConfigInterface"))),(0,l.kt)("br",null),(0,l.kt)("h4",{id:"key"},(0,l.kt)("inlineCode",{parentName:"h4"},"key")),(0,l.kt)("p",null,"The ",(0,l.kt)("inlineCode",{parentName:"p"},"key/name")," of the Job that is created and ingested into the ",(0,l.kt)("inlineCode",{parentName:"p"},"runtime"),"."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-ts"},"MY_STATE.set('hello there', {key: 'jeff'});\n")),(0,l.kt)("p",null,"Such key can be very useful during debug sessions\nin order to analyse when which Job ran through the ",(0,l.kt)("inlineCode",{parentName:"p"},"runtime"),"."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-ts"},"// Agile Debug: Created Job 'jeff', Job('jeff')\n// Agile Debug: Completed Job 'jeff', Job('jeff')\n// Agile Debug: Updated/Rerendered Subscriptions, [SubscriptionContainer, ..]\n")),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Default"),(0,l.kt)("th",{parentName:"tr",align:null},"Required"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"string \\| number")),(0,l.kt)("td",{parentName:"tr",align:null},"undefined"),(0,l.kt)("td",{parentName:"tr",align:null},"No")))),(0,l.kt)("br",null),(0,l.kt)("hr",null),(0,l.kt)("br",null),(0,l.kt)("h2",{id:"stateruntimejobconfig"},(0,l.kt)("inlineCode",{parentName:"h2"},"StateRuntimeJobConfig")),(0,l.kt)("p",null,"The ",(0,l.kt)("inlineCode",{parentName:"p"},"StateRuntimeJobConfigInterface")," is used as configuration object in functions like ",(0,l.kt)("a",{parentName:"p",href:"/test/docs/core/collection/group/methods#replace"},(0,l.kt)("inlineCode",{parentName:"a"},"replace()"))," or ",(0,l.kt)("a",{parentName:"p",href:"/test/docs/core/collection/selector/methods#select"},(0,l.kt)("inlineCode",{parentName:"a"},"select()")),".\nHere is a Typescript Interface for quick reference. However,\neach property is explained in more detail below."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-ts"},"export interface StateRuntimeJobConfigInterface\n  extends RuntimeJobConfigInterface {\n  overwrite?: boolean;\n  storage?: boolean;\n}\n")),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Note:")," The ",(0,l.kt)("inlineCode",{parentName:"p"},"StateRuntimeJobConfigInterface")," extends some other Interfaces:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("a",{parentName:"li",href:"#runtimejobconfiginterface"},"RuntimeJobConfigInterface"))),(0,l.kt)("br",null),(0,l.kt)("h4",{id:"overwrite"},(0,l.kt)("inlineCode",{parentName:"h4"},"overwrite")),(0,l.kt)("p",null,"If ",(0,l.kt)("inlineCode",{parentName:"p"},"true"),", the whole State is overwritten with the newly assigned ",(0,l.kt)("inlineCode",{parentName:"p"},"value"),"."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-ts",metastring:"{1}","{1}":!0},"MY_STATE.set(\"finalValue\", {overwrite: true});\nMY_STATE.value; // Returns 'finalValue'\nMY_STATE.previousStateValue; // Returns 'finalValue'\nMY_STATE.initialStateValue; // Returns 'finalValue'\n")),(0,l.kt)("p",null,"During the overwrite process, the following properties are overwritten:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"value")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"previousStateValue")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"initalStateValue")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"isPlaceholder"))),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Default"),(0,l.kt)("th",{parentName:"tr",align:null},"Required"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"boolean")),(0,l.kt)("td",{parentName:"tr",align:null},"false"),(0,l.kt)("td",{parentName:"tr",align:null},"No")))),(0,l.kt)("br",null),(0,l.kt)("h4",{id:"storage"},(0,l.kt)("inlineCode",{parentName:"h4"},"storage")),(0,l.kt)("p",null,"Whether to apply the State value changes to the corresponding external ",(0,l.kt)("a",{parentName:"p",href:"/test/docs/core/storage"},"Storage/s"),"."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-ts",metastring:"{1}","{1}":!0},"const MY_STATE = App.creacteState('jeff').persist('storageKey');\n// Storage at 'storageKey': 'jeff'\nMY_STATE.set(\"hans\", {storage: true});\n// Storage at 'storageKey': 'hans'\nMY_STATE.set(\"dieter\", {storage: false});\n// Storage at 'storageKey': 'hans'\n")),(0,l.kt)("p",null,"Be aware that this is only relevant, if the State is ",(0,l.kt)("a",{parentName:"p",href:"/test/docs/core/state/methods#persist"},"persisted"),".\nWe can use the ",(0,l.kt)("inlineCode",{parentName:"p"},"isPersisted")," property to check whether a state is persisted."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-ts"},"MY_STATE.isPersisted;\n")),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Default"),(0,l.kt)("th",{parentName:"tr",align:null},"Required"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"boolean")),(0,l.kt)("td",{parentName:"tr",align:null},"true"),(0,l.kt)("td",{parentName:"tr",align:null},"No")))),(0,l.kt)("br",null),(0,l.kt)("hr",null),(0,l.kt)("br",null),(0,l.kt)("h2",{id:"runtimejobconfiginterface"},(0,l.kt)("inlineCode",{parentName:"h2"},"RuntimeJobConfigInterface")),(0,l.kt)("p",null,"The ",(0,l.kt)("inlineCode",{parentName:"p"},"RuntimeJobConfigInterface")," is used in the creation and configuration of a ",(0,l.kt)("inlineCode",{parentName:"p"},"Runtime Job"),".\nHere is a Typescript Interface for quick reference. However,\neach property is explained in more detail below."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-ts"},"export interface RuntimeJobConfigInterface {\n  background?: boolean;\n  sideEffects?: SideEffectConfigInterface;\n  force?: boolean;\n  numberOfTriesToUpdate?: number | null;\n}\n")),(0,l.kt)("br",null),(0,l.kt)("h4",{id:"background"},(0,l.kt)("inlineCode",{parentName:"h4"},"background")),(0,l.kt)("p",null,"When ",(0,l.kt)("inlineCode",{parentName:"p"},"true"),", the Job is executed in the ",(0,l.kt)("inlineCode",{parentName:"p"},"background"),"\nand won't cause any rerender on Components that have subscribed the ",(0,l.kt)("a",{parentName:"p",href:"/test/docs/introduction/#agile-sub-instance"},"Agile Sub Instance"),"\nrepresented by the Job."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-ts",metastring:"{5}","{5}":!0},'// Causes rerender on Components\nMY_STATE.set("myNewValue2");\n  \n// Doesn\'t cause rerender on Components\nMY_STATE.set("myNewValue3", {background: true});\n')),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Default"),(0,l.kt)("th",{parentName:"tr",align:null},"Required"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"boolean")),(0,l.kt)("td",{parentName:"tr",align:null},"false"),(0,l.kt)("td",{parentName:"tr",align:null},"No")))),(0,l.kt)("br",null),(0,l.kt)("h4",{id:"sideeffects"},(0,l.kt)("inlineCode",{parentName:"h4"},"sideEffects")),(0,l.kt)("p",null,"Specifies whether the side effects of the Job should be executed."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-ts",metastring:"{5}","{5}":!0},'// Executes sideEffects\nMY_STATE.set("myNewValue2");\n  \n// Doesn\'t execute sideEffects\nMY_STATE.set("myNewValue3", {sideEffects: false});\n')),(0,l.kt)("p",null,"During a side effect, several essential tasks are done.\nThese include, for example, ",(0,l.kt)("em",{parentName:"p"},"rebuilding the Group output")," of a Group\nor ",(0,l.kt)("em",{parentName:"p"},"updating the persisted State value in the corresponding external Storage"),"."),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Default"),(0,l.kt)("th",{parentName:"tr",align:null},"Required"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"boolean")),(0,l.kt)("td",{parentName:"tr",align:null},"true"),(0,l.kt)("td",{parentName:"tr",align:null},"No")))),(0,l.kt)("br",null),(0,l.kt)("h4",{id:"force"},(0,l.kt)("inlineCode",{parentName:"h4"},"force")),(0,l.kt)("p",null,"When set to ",(0,l.kt)("inlineCode",{parentName:"p"},"true"),", the Job is forced through the ",(0,l.kt)("inlineCode",{parentName:"p"},"runtime")," no matter what happens."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-ts",metastring:"{7}","{7}":!0},"const MY_STATE = App.createState('myValue');\n\n// Won't be executed by the runtime because the State value hasn't changed\nMY_STATE.set('myValue');\n  \n// Will be executed by the runtime, although the State value hasn't changed\nMY_STATE.set('myValue', { force: true });\n")),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Default"),(0,l.kt)("th",{parentName:"tr",align:null},"Required"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"boolean")),(0,l.kt)("td",{parentName:"tr",align:null},"false"),(0,l.kt)("td",{parentName:"tr",align:null},"No")))),(0,l.kt)("h4",{id:"numberoftriestoupdate"},(0,l.kt)("inlineCode",{parentName:"h4"},"numberOfTriesToUpdate")),(0,l.kt)("p",null,"How often the runtime should try to update not ready SubscriptionContainers of the Job.\nIf the update tries count exceeds the ",(0,l.kt)("inlineCode",{parentName:"p"},"numberOfTriesToUpdate")," count,\nthe Job will be entirely removed from the runtime.\nThis has the advantage that an overflow of the runtime is avoided.\nIf ",(0,l.kt)("inlineCode",{parentName:"p"},"numberOfTriesToUpdate")," is ",(0,l.kt)("inlineCode",{parentName:"p"},"null")," the runtime tries to update the not ready Job subscriptionContainers\nuntil they are ready."),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Default"),(0,l.kt)("th",{parentName:"tr",align:null},"Required"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"number \\| null")),(0,l.kt)("td",{parentName:"tr",align:null},"3"),(0,l.kt)("td",{parentName:"tr",align:null},"No")))),(0,l.kt)("br",null),(0,l.kt)("hr",null),(0,l.kt)("br",null),(0,l.kt)("h2",{id:"ingestconfiginterface"},(0,l.kt)("inlineCode",{parentName:"h2"},"IngestConfigInterface")),(0,l.kt)("p",null,"The ",(0,l.kt)("inlineCode",{parentName:"p"},"IngestConfigInterface")," is used as a configuration object to configure the ingest process of ",(0,l.kt)("inlineCode",{parentName:"p"},"Jobs")," into the ",(0,l.kt)("inlineCode",{parentName:"p"},"runtime"),".\nHere is a Typescript Interface for quick reference. However,\neach property is explained in more detail below."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-ts"},"export interface IngestConfigInterface {\n  perform?: boolean;\n}\n")),(0,l.kt)("br",null),(0,l.kt)("h4",{id:"perform"},(0,l.kt)("inlineCode",{parentName:"h4"},"perform")),(0,l.kt)("p",null,"Whether the ingested Job should be executed immediately by the ",(0,l.kt)("inlineCode",{parentName:"p"},"runtime"),"\nor should first be inserted into a ",(0,l.kt)("inlineCode",{parentName:"p"},"queue")," and performed when it is its turn."),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Default"),(0,l.kt)("th",{parentName:"tr",align:null},"Required"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"boolean")),(0,l.kt)("td",{parentName:"tr",align:null},"true"),(0,l.kt)("td",{parentName:"tr",align:null},"No")))),(0,l.kt)("br",null),(0,l.kt)("hr",null),(0,l.kt)("br",null),(0,l.kt)("h2",{id:"patchconfig"},(0,l.kt)("inlineCode",{parentName:"h2"},"PatchConfig")),(0,l.kt)("p",null,"The ",(0,l.kt)("inlineCode",{parentName:"p"},"PatchConfigInterface")," is used as configuration object in functions like ",(0,l.kt)("a",{parentName:"p",href:"/test/docs/core/state/methods#persist"},(0,l.kt)("inlineCode",{parentName:"a"},"patch()")),".\nHere is a Typescript Interface for quick reference. However,\neach property is explained in more detail below."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-ts"},"export interface PatchConfigInterface extends StateIngestConfigInterface {\n  addNewProperties?: boolean;\n}\n")),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Note:")," The ",(0,l.kt)("inlineCode",{parentName:"p"},"PatchConfigInterface")," extends some other Interfaces:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("a",{parentName:"li",href:"#stateingestconfig"},"StateIngestConfigInterface"))),(0,l.kt)("br",null),(0,l.kt)("h4",{id:"addnewproperties"},(0,l.kt)("inlineCode",{parentName:"h4"},"addNewProperties")),(0,l.kt)("p",null,"If ",(0,l.kt)("inlineCode",{parentName:"p"},"true"),", new properties are added to the State value, although they might not yet be present there."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-ts",metastring:"{2,4}","{2,4}":!0},'const MY_STATE = App.createState({id: 1, name: "frank"});\nMY_STATE.patch({location: "Germany"}, {addNewProperties: false}); \nMY_STATE.value; // Returns {id: 1, name: "frank"}\nMY_STATE.patch({location: "Germany"}, {addNewProperties: true});\nMY_STATE.value; // Returns {id: 1, name: "frank", location: "Germany"}\n')),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Default"),(0,l.kt)("th",{parentName:"tr",align:null},"Required"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"boolean")),(0,l.kt)("td",{parentName:"tr",align:null},"true"),(0,l.kt)("td",{parentName:"tr",align:null},"No")))),(0,l.kt)("br",null),(0,l.kt)("hr",null),(0,l.kt)("br",null),(0,l.kt)("h2",{id:"statepersistentconfig"},(0,l.kt)("inlineCode",{parentName:"h2"},"StatePersistentConfig")),(0,l.kt)("p",null,"The ",(0,l.kt)("inlineCode",{parentName:"p"},"StatePersistentConfigInterface")," is used as configuration object in functions like ",(0,l.kt)("a",{parentName:"p",href:"/test/docs/core/state/methods#persist"},(0,l.kt)("inlineCode",{parentName:"a"},"persist()")),".\nHere is a Typescript Interface for quick reference. However,\neach property is explained in more detail below."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-ts"},"export interface StatePersistentConfigInterface {\n   loadValue?: boolean;\n   storageKeys?: StorageKey[];\n}\n")),(0,l.kt)("br",null),(0,l.kt)("h4",{id:"loadvalue"},(0,l.kt)("inlineCode",{parentName:"h4"},"loadValue")),(0,l.kt)("p",null,"When ",(0,l.kt)("inlineCode",{parentName:"p"},"true"),", the created ",(0,l.kt)("inlineCode",{parentName:"p"},"Persistent")," automatically loads the value stored in the corresponding external Storage into the State.\nOr, if the State isn't persisted yet, it stores the State value in the corresponding external Storage.\nBe aware that if we don't allow the ",(0,l.kt)("inlineCode",{parentName:"p"},"Persistent")," to load/store the value, we have to do it ourselves."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-ts",metastring:"{2}","{2}":!0},"myState.persist({\n   instantiate: false,\n});\n\nif (myState.persistent?.ready) {\n   await myState.persistent?.initialLoading();\n    myState.isPersisted = true;\n}\n")),(0,l.kt)("p",null,"Loading the value manually has one advantage.\nIt allows us to await the asynchronous load/store process.\nIf you only need to await the loading process we recommend using the ",(0,l.kt)("a",{parentName:"p",href:"/test/docs/core/state/methods#onload"},(0,l.kt)("inlineCode",{parentName:"a"},"onLoad()"))," method."),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Default"),(0,l.kt)("th",{parentName:"tr",align:null},"Required"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"boolean")),(0,l.kt)("td",{parentName:"tr",align:null},"true"),(0,l.kt)("td",{parentName:"tr",align:null},"No")))),(0,l.kt)("br",null),(0,l.kt)("h4",{id:"storagekeys"},(0,l.kt)("inlineCode",{parentName:"h4"},"storageKeys")),(0,l.kt)("p",null,"Specifies the ",(0,l.kt)("a",{parentName:"p",href:"/test/docs/core/storage"},"Storage/s")," the State value should be persisted in."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-ts"},"MY_STATE.persist(); // Stores value in default Storage\nMY_STATE.persist({storageKeys: ['myCustomStorrage']}); // Stores value in 'myCustomStorrage'\n")),(0,l.kt)("p",null,"If no specific Storage defined, the State value will be stored/persisted in the ",(0,l.kt)("a",{parentName:"p",href:"/test/docs/core/persisting-data#-default-storage"},"default Storage"),"."),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Default"),(0,l.kt)("th",{parentName:"tr",align:null},"Required"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"Array<string \\| number>")),(0,l.kt)("td",{parentName:"tr",align:null},"'defaultStorage'"),(0,l.kt)("td",{parentName:"tr",align:null},"No")))),(0,l.kt)("br",null),(0,l.kt)("hr",null),(0,l.kt)("br",null),(0,l.kt)("h2",{id:"groupconfig"},(0,l.kt)("inlineCode",{parentName:"h2"},"GroupConfig")),(0,l.kt)("p",null,"The ",(0,l.kt)("inlineCode",{parentName:"p"},"GroupConfigInterface")," is used in the creation and configuration of the ",(0,l.kt)("a",{parentName:"p",href:"/test/docs/core/collection/group"},(0,l.kt)("inlineCode",{parentName:"a"},"Group Class")),".\nHere is a Typescript Interface for quick reference. However,\neach property is explained in more detail below."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-ts"},"export interface GroupConfigInterface {\n  key?: GroupKey;\n  isPlaceholder?: boolean;\n}\n")),(0,l.kt)("br",null),(0,l.kt)("h4",{id:"key-1"},(0,l.kt)("inlineCode",{parentName:"h4"},"key")),(0,l.kt)("p",null,"The optional property ",(0,l.kt)("inlineCode",{parentName:"p"},"key/name")," should be a unique ",(0,l.kt)("inlineCode",{parentName:"p"},"string/number")," to identify the Group later."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-ts"},'MY_COLLECTION.createGroup([1, 2, 3], {\n    key: "myKey"\n});\n')),(0,l.kt)("p",null,"We recommend giving each Group a unique ",(0,l.kt)("inlineCode",{parentName:"p"},"key")," since it has only advantages:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"helps us during debug sessions"),(0,l.kt)("li",{parentName:"ul"},"makes it easier to identify the Group"),(0,l.kt)("li",{parentName:"ul"},"no need for separate persist Key")),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Default"),(0,l.kt)("th",{parentName:"tr",align:null},"Required"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"string \\| name")),(0,l.kt)("td",{parentName:"tr",align:null},"undefined"),(0,l.kt)("td",{parentName:"tr",align:null},"No")))),(0,l.kt)("br",null),(0,l.kt)("h4",{id:"isplaceholder"},(0,l.kt)("inlineCode",{parentName:"h4"},"isPlaceholder")),(0,l.kt)("p",null,"Defines whether the Group is a ",(0,l.kt)("inlineCode",{parentName:"p"},"placeholder"),"."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-ts"},"const MY_GROUP = App.createGroup([1, 2, 3], {\n    isPlaceholder: true\n});\n\nMY_GROUP.exists(); // false\n")),(0,l.kt)("p",null,"Groups are ",(0,l.kt)("inlineCode",{parentName:"p"},"placeholder")," when AgileTs needs to hold a reference to them,\neven though they aren't instantiated yet.\nThis can be the case if we use the ",(0,l.kt)("inlineCode",{parentName:"p"},"getGroupWithReference()")," method,\nwhich returns a ",(0,l.kt)("inlineCode",{parentName:"p"},"placeholder")," Group if the Group we are looking for doesn't exist yet."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-ts"},'const myGroup = useAgile(MY_COLLECTION.getGroupWithReference("group1")); // Causes rerender if Group got created\nconst myGroup2 = useAgile(MY_COLLECTION.getGroup("group2")); // Doesn\'t causes rerender if Group got created\n')),(0,l.kt)("p",null,"This reference is essential to rerender the Component,\nwhenever the Group got instantiated."),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Default"),(0,l.kt)("th",{parentName:"tr",align:null},"Required"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"boolean")),(0,l.kt)("td",{parentName:"tr",align:null},"false"),(0,l.kt)("td",{parentName:"tr",align:null},"No")))),(0,l.kt)("br",null),(0,l.kt)("hr",null),(0,l.kt)("br",null),(0,l.kt)("h2",{id:"selectorconfig"},(0,l.kt)("inlineCode",{parentName:"h2"},"SelectorConfig")),(0,l.kt)("p",null,"The ",(0,l.kt)("inlineCode",{parentName:"p"},"SelectorConfigInterface")," is used in the creation and configuration of the ",(0,l.kt)("a",{parentName:"p",href:"/test/docs/core/collection/selector"},(0,l.kt)("inlineCode",{parentName:"a"},"Selector Class")),".\nHere is a Typescript Interface for quick reference. However,\neach property is explained in more detail below."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-ts"},"export interface SelectorConfigInterface {\n  key?: SelectorKey;\n  isPlaceholder?: boolean;\n}\n")),(0,l.kt)("br",null),(0,l.kt)("h4",{id:"key-2"},(0,l.kt)("inlineCode",{parentName:"h4"},"key")),(0,l.kt)("p",null,"The optional property ",(0,l.kt)("inlineCode",{parentName:"p"},"key/name")," should be a unique ",(0,l.kt)("inlineCode",{parentName:"p"},"string/number")," to identify the Selector later."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-ts"},'MY_COLLECTION.createSelector(1, {\n    key: "myKey"\n});\n')),(0,l.kt)("p",null,"We recommend giving each Selector a unique ",(0,l.kt)("inlineCode",{parentName:"p"},"key")," since it has only advantages:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"helps us during debug sessions"),(0,l.kt)("li",{parentName:"ul"},"makes it easier to identify the Selector"),(0,l.kt)("li",{parentName:"ul"},"no need for separate persist Key")),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Default"),(0,l.kt)("th",{parentName:"tr",align:null},"Required"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"string \\| name")),(0,l.kt)("td",{parentName:"tr",align:null},"undefined"),(0,l.kt)("td",{parentName:"tr",align:null},"No")))),(0,l.kt)("br",null),(0,l.kt)("h4",{id:"isplaceholder-1"},(0,l.kt)("inlineCode",{parentName:"h4"},"isPlaceholder")),(0,l.kt)("p",null,"Defines whether the Selector is a ",(0,l.kt)("inlineCode",{parentName:"p"},"placeholder"),"."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-ts"},"const MY_SELECTOR = App.creaateSelector(1, {\n    isPlaceholder: true\n});\n\nMY_SELECTOR.exists(); // false\n")),(0,l.kt)("p",null,"Selectors are ",(0,l.kt)("inlineCode",{parentName:"p"},"placeholder")," when AgileTs needs to hold a reference to them,\neven though they aren't instantiated yet.\nThis can be the case if we use the ",(0,l.kt)("inlineCode",{parentName:"p"},"getSelectorWithReference()")," method,\nwhich returns a ",(0,l.kt)("inlineCode",{parentName:"p"},"placeholder")," Selector if the Selector we are looking for doesn't exist yet."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-ts"},'const mySeleector = useAgile(MY_COLLECTION.getSelectorWithReference("selector1")); // Causes rerender if Selector got created\nconst mySeleector2 = useAgile(MY_COLLECTION.getSelector("selector2")); // Doesn\'t causes rerender if Selector got created\n')),(0,l.kt)("p",null,"This reference is essential to rerender the Component,\nwhenever the Selector got instantiated."),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Default"),(0,l.kt)("th",{parentName:"tr",align:null},"Required"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"boolean")),(0,l.kt)("td",{parentName:"tr",align:null},"false"),(0,l.kt)("td",{parentName:"tr",align:null},"No")))),(0,l.kt)("br",null),(0,l.kt)("hr",null),(0,l.kt)("br",null),(0,l.kt)("h2",{id:"collectconfig"},(0,l.kt)("inlineCode",{parentName:"h2"},"CollectConfig")),(0,l.kt)("p",null,"The ",(0,l.kt)("inlineCode",{parentName:"p"},"CollectConfigInterface")," is used as configuration object in functions like ",(0,l.kt)("a",{parentName:"p",href:"/test/docs/core/collection/methods#collect"},(0,l.kt)("inlineCode",{parentName:"a"},"collect()")),".\nHere is a Typescript Interface for quick reference. However,\neach property is explained in more detail below."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-ts"},"export interface CollectConfigInterface<DataType = any> {\n  patch?: boolean;\n  method?: 'push' | 'unshift';\n  forEachItem?: (data: DataType, key: ItemKey, index: number) => void;\n  background?: boolean;\n  select?: boolean;\n}\n")),(0,l.kt)("br",null),(0,l.kt)("h4",{id:"patch"},(0,l.kt)("inlineCode",{parentName:"h4"},"patch")),(0,l.kt)("div",{className:"admonition admonition-info alert alert--info"},(0,l.kt)("div",{parentName:"div",className:"admonition-heading"},(0,l.kt)("h5",{parentName:"div"},(0,l.kt)("span",{parentName:"h5",className:"admonition-icon"},"\u2757\ufe0f"),"info")),(0,l.kt)("div",{parentName:"div",className:"admonition-content"},(0,l.kt)("p",{parentName:"div"},"The ",(0,l.kt)("inlineCode",{parentName:"p"},"patch")," property is only relevant to us\nif we collect a data object with an already existing ",(0,l.kt)("inlineCode",{parentName:"p"},"primaryKey")," in order to update the Item data at that ",(0,l.kt)("inlineCode",{parentName:"p"},"primaryKey"),"."))),(0,l.kt)("p",null,"If ",(0,l.kt)("inlineCode",{parentName:"p"},"true"),", the passed data object is merged into the found Item data instead of overwriting it entirely."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-ts",metastring:"{6,9}","{6,9}":!0},"const MY_COLLECTION = App.createCollection({\n    initialData: [{id: 1, name: 'frank', age: 10}]\n});\n\nMY_COLLECTION.collect({id: 1, name: 'hans'}, [], {patch: true});\nMY_COLLECTION.getItemValue(1); // Returns '{id: 1, name: 'hans', age: 10}'\n\nMY_COLLECTION.collect({id: 1, name: 'jeff'}, [], {patch: false});\nMY_COLLECTION.getItemValue(1); // Returns '{id: 1, name: 'frank'}'\n")),(0,l.kt)("p",null,"An alternative to this way of updating already existing Item data is the ",(0,l.kt)("a",{parentName:"p",href:"/test/docs/core/collection/methods#update"},(0,l.kt)("inlineCode",{parentName:"a"},"update()"))," method."),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Default"),(0,l.kt)("th",{parentName:"tr",align:null},"Required"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"boolean")),(0,l.kt)("td",{parentName:"tr",align:null},"false"),(0,l.kt)("td",{parentName:"tr",align:null},"No")))),(0,l.kt)("br",null),(0,l.kt)("h4",{id:"method"},(0,l.kt)("inlineCode",{parentName:"h4"},"method")),(0,l.kt)("p",null,"Specifies the way of adding the collected data ",(0,l.kt)("inlineCode",{parentName:"p"},"primaryKey/s")," to the defined Group/s."),(0,l.kt)("h5",{id:"push"},(0,l.kt)("inlineCode",{parentName:"h5"},"push")),(0,l.kt)("p",null,"The ",(0,l.kt)("inlineCode",{parentName:"p"},"primaryKey")," is added to the ",(0,l.kt)("strong",{parentName:"p"},"end")," of the Group value array."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-ts",metastring:"{2}","{2}":!0},"MY_COLLECTION.collect({id: 1, name: \"jeff\"}, [], {method: 'push'});\nMY_COLLECTION.getGroup(MY_COLLECTION.config.defaultGroupKey).value; // Returns [5, 6, 0, 1]\n")),(0,l.kt)("h5",{id:"unshift"},(0,l.kt)("inlineCode",{parentName:"h5"},"unshift")),(0,l.kt)("p",null,"The ",(0,l.kt)("inlineCode",{parentName:"p"},"primaryKey")," is added to the ",(0,l.kt)("strong",{parentName:"p"},"beginning")," of the Group value array."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-ts",metastring:"{2}","{2}":!0},"MY_COLLECTION.collect({id: 8, name: \"jeff\"}, [], {method: 'unshift'});\nMY_COLLECTION.getGroup(MY_COLLECTION.config.defaultGroupKey).value; // Returns [8, 5, 6, 0, 1]\n")),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Default"),(0,l.kt)("th",{parentName:"tr",align:null},"Required"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"push' \\| 'unshift'")),(0,l.kt)("td",{parentName:"tr",align:null},"'push'"),(0,l.kt)("td",{parentName:"tr",align:null},"No")))),(0,l.kt)("br",null),(0,l.kt)("h4",{id:"foreachitem"},(0,l.kt)("inlineCode",{parentName:"h4"},"forEachItem")),(0,l.kt)("p",null,"Callback that is called for each collected data object."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-ts",metastring:"{4-9}","{4-9}":!0},'MY_COLLECTION.collect([\n    {id: 1, name: "jeff"}, \n    {id: 8, name: "frank"}], \n    [],\n    {forEachItem: (data, key, index) => {\n         // Is called with \'data: {id: 1, name: "jeff"}, key: 1, index: 0\'\n         // and   \n         // Is called with \'data: {id: 2, name: "frank"}, key: 8, index: 1\'\n      }\n    });\n')),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Default"),(0,l.kt)("th",{parentName:"tr",align:null},"Required"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"(data: DataType, key: ItemKey, index: number) => void")),(0,l.kt)("td",{parentName:"tr",align:null},"undefined"),(0,l.kt)("td",{parentName:"tr",align:null},"No")))),(0,l.kt)("br",null),(0,l.kt)("h4",{id:"background-1"},(0,l.kt)("inlineCode",{parentName:"h4"},"background")),(0,l.kt)("p",null,"When ",(0,l.kt)("inlineCode",{parentName:"p"},"true"),", the data object/s are collected in ",(0,l.kt)("inlineCode",{parentName:"p"},"background"),"\nand won't cause any rerender on Components that have subscribed the Collection."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-ts",metastring:"{5}","{5}":!0},'  // Causes rerender on Components\n  MY_COLLECTION.collect({id: 1, name: "jeff"});\n  \n  // Doesn\'t cause rerender on Components\n  MY_COLLECTION.collect({id: 1, name: "jeff"}, {background: true});\n')),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Default"),(0,l.kt)("th",{parentName:"tr",align:null},"Required"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"boolean")),(0,l.kt)("td",{parentName:"tr",align:null},"false"),(0,l.kt)("td",{parentName:"tr",align:null},"No")))),(0,l.kt)("br",null),(0,l.kt)("h4",{id:"select"},(0,l.kt)("inlineCode",{parentName:"h4"},"select")),(0,l.kt)("p",null,"If ",(0,l.kt)("inlineCode",{parentName:"p"},"true"),", a ",(0,l.kt)("a",{parentName:"p",href:"/test/docs/core/collection/selector"},"Selector")," is created for each collected data object."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-ts",metastring:"{1}","{1}":!0},"MY_COLLECTION.collect({id: 1, name: \"jeff\"}, {select: true});\nMY_COLLECTION.getSelector(1); // Returns Selector at '1'\n")),(0,l.kt)("p",null,"These created Selectors can be identified with the same key used as ",(0,l.kt)("inlineCode",{parentName:"p"},"primaryKey")," in the collected data object."),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Default"),(0,l.kt)("th",{parentName:"tr",align:null},"Required"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"boolean")),(0,l.kt)("td",{parentName:"tr",align:null},"false"),(0,l.kt)("td",{parentName:"tr",align:null},"No")))),(0,l.kt)("br",null),(0,l.kt)("hr",null),(0,l.kt)("br",null),(0,l.kt)("h2",{id:"updateconfig"},(0,l.kt)("inlineCode",{parentName:"h2"},"UpdateConfig")),(0,l.kt)("p",null,"The ",(0,l.kt)("inlineCode",{parentName:"p"},"UpdateConfigInterface")," is used as configuration object in functions like ",(0,l.kt)("a",{parentName:"p",href:"/test/docs/core/collection/methods#update"},(0,l.kt)("inlineCode",{parentName:"a"},"update()")),".\nHere is a Typescript Interface for quick reference. However,\neach property is explained in more detail below."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-ts"},"export interface UpdateConfigInterface {\n    patch?: boolean | { addNewProperties?: boolean };\n    background?: boolean;\n}\n")),(0,l.kt)("br",null),(0,l.kt)("h4",{id:"patch-1"},(0,l.kt)("inlineCode",{parentName:"h4"},"patch")),(0,l.kt)("p",null,"If ",(0,l.kt)("inlineCode",{parentName:"p"},"false"),", the passed data object overwrites the entire found Item data instead of merging it into the Item data."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-ts",metastring:"{2, 4}","{2,":!0,"4}":!0},'MY_COLLECTION.collect({id: 1, name: "jeff"});\nMY_COLLECTION.update(1, {name: "hans"}, {patch: true}); \nMY_COLLECTION.getItemValue(1); // Returns \'{id: 1, name: "hans"}\'\nMY_COLLECTION.update(1, {name: "frank"}, {patch: false}); \nMY_COLLECTION.getItemValue(1); // Returns \'{name: "frank"}\'\n')),(0,l.kt)("p",null,"Keep in mind that if we decide to overwrite the entire Item data object,\nwe have to redefine the ",(0,l.kt)("inlineCode",{parentName:"p"},"primaryKey")," in the given data object.\nOtherwise, the ",(0,l.kt)("inlineCode",{parentName:"p"},"primary Key")," gets missing, which can lead to problems."),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Default"),(0,l.kt)("th",{parentName:"tr",align:null},"Required"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"boolean")),(0,l.kt)("td",{parentName:"tr",align:null},"true"),(0,l.kt)("td",{parentName:"tr",align:null},"No")))),(0,l.kt)("br",null),(0,l.kt)("h4",{id:"background-2"},(0,l.kt)("inlineCode",{parentName:"h4"},"background")),(0,l.kt)("p",null,"When ",(0,l.kt)("inlineCode",{parentName:"p"},"true"),", the Item data object is updated in ",(0,l.kt)("inlineCode",{parentName:"p"},"background"),"\nand won't cause any rerender on Components that have subscribed the Item or Collection."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-ts",metastring:"{5}","{5}":!0},'// Causes rerender on Components\nMY_COLLECTION.update(1, {name: "jeff"});\n\n// Doesn\'t cause rerender on Components\nMY_COLLECTION.update(1, {name: "frank"}, {background: true});\n')),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Default"),(0,l.kt)("th",{parentName:"tr",align:null},"Required"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"boolean")),(0,l.kt)("td",{parentName:"tr",align:null},"false"),(0,l.kt)("td",{parentName:"tr",align:null},"No")))),(0,l.kt)("br",null),(0,l.kt)("hr",null),(0,l.kt)("br",null),(0,l.kt)("h2",{id:"hasconfig"},(0,l.kt)("inlineCode",{parentName:"h2"},"HasConfig")),(0,l.kt)("p",null,"The ",(0,l.kt)("inlineCode",{parentName:"p"},"HasConfigInterface")," is used as configuration object in functions like ",(0,l.kt)("a",{parentName:"p",href:"/test/docs/core/collection/methods#hasgroup"},(0,l.kt)("inlineCode",{parentName:"a"},"hasGroup()"))," or ",(0,l.kt)("a",{parentName:"p",href:"/test/docs/core/collection/methods#hasselector"},(0,l.kt)("inlineCode",{parentName:"a"},"hasSelector()")),".\nHere is a Typescript Interface for quick reference. However,\neach property is explained in more detail below."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-ts"},"export interface HasConfigInterface {\n  notExisting?: boolean;\n}\n")),(0,l.kt)("br",null),(0,l.kt)("h4",{id:"notexisting"},(0,l.kt)("inlineCode",{parentName:"h4"},"notExisting")),(0,l.kt)("p",null,"When ",(0,l.kt)("inlineCode",{parentName:"p"},"true"),", also not officially existing Instances (like ",(0,l.kt)("inlineCode",{parentName:"p"},"placeholder"),") can be found."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-ts",metastring:"{2,5}","{2,5}":!0},"// Returns placeholder Group\nMY_COLLECTION.hasGroup('myPlaceholderGroup', {notExisting: true});\n\n// Returns undefined\nMY_COLLECTION.hasGroup('myPlaceholderGroup');\n")),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Default"),(0,l.kt)("th",{parentName:"tr",align:null},"Required"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"boolean")),(0,l.kt)("td",{parentName:"tr",align:null},"false"),(0,l.kt)("td",{parentName:"tr",align:null},"No")))),(0,l.kt)("br",null),(0,l.kt)("hr",null),(0,l.kt)("br",null),(0,l.kt)("h2",{id:"addsideeffectconfig"},(0,l.kt)("inlineCode",{parentName:"h2"},"AddSideEffectConfig")),(0,l.kt)("p",null,"The ",(0,l.kt)("inlineCode",{parentName:"p"},"AddSideEffectConfigInterface")," is used as configuration object in functions like ",(0,l.kt)("a",{parentName:"p",href:"/test/docs/core/state/methods#addsideeffect"},(0,l.kt)("inlineCode",{parentName:"a"},"addSideEffect()")),".\nHere is a Typescript Interface for quick reference. However,\neach property is explained in more detail below."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-ts"},"export interface AddSideEffectConfigInterface {\n    weight?: number;\n}\n")),(0,l.kt)("br",null),(0,l.kt)("h4",{id:"weight"},(0,l.kt)("inlineCode",{parentName:"h4"},"weight")),(0,l.kt)("p",null,"Defines the ",(0,l.kt)("inlineCode",{parentName:"p"},"weight")," of the ",(0,l.kt)("inlineCode",{parentName:"p"},"sideEffect"),"\nand thus when it is executed."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-ts",metastring:"{3}","{3}":!0},"MY_STATE.addSideEffect('mySideEffect', (state, config) => {\n    // sideEffect callback\n}, {weigth: 10});\n")),(0,l.kt)("p",null,"The higher the ",(0,l.kt)("inlineCode",{parentName:"p"},"weight"),", the earlier the ",(0,l.kt)("inlineCode",{parentName:"p"},"sideEffect")," is performed."),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Default"),(0,l.kt)("th",{parentName:"tr",align:null},"Required"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"number")),(0,l.kt)("td",{parentName:"tr",align:null},"10"),(0,l.kt)("td",{parentName:"tr",align:null},"No")))),(0,l.kt)("br",null),(0,l.kt)("hr",null),(0,l.kt)("br",null),(0,l.kt)("h2",{id:"groupaddconfig"},(0,l.kt)("inlineCode",{parentName:"h2"},"GroupAddConfig")),(0,l.kt)("p",null,"The ",(0,l.kt)("inlineCode",{parentName:"p"},"GroupAddConfigInterface")," is used as configuration object in functions like ",(0,l.kt)("a",{parentName:"p",href:"/test/docs/core/collection/methods#put"},(0,l.kt)("inlineCode",{parentName:"a"},"put()"))," or ",(0,l.kt)("a",{parentName:"p",href:"/test/docs/core/collection/group/methods#add"},(0,l.kt)("inlineCode",{parentName:"a"},"add()")),".\nHere is a Typescript Interface for quick reference. However,\neach property is explained in more detail below."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-ts"},"export interface GroupAddConfig extends StateIngestConfigInterface {\n    method?: 'unshift' | 'push';\n    overwrite?: boolean;\n}\n")),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Note:")," The ",(0,l.kt)("inlineCode",{parentName:"p"},"GroupAddConfig")," extends some other Interfaces:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("a",{parentName:"li",href:"#stateingestconfig"},"StateIngestConfigInterface"))),(0,l.kt)("br",null),(0,l.kt)("h4",{id:"method-1"},(0,l.kt)("inlineCode",{parentName:"h4"},"method")),(0,l.kt)("p",null,"Specifies the way of adding the collected data ",(0,l.kt)("inlineCode",{parentName:"p"},"primaryKey/s")," to the defined Group/s."),(0,l.kt)("h5",{id:"push-1"},(0,l.kt)("inlineCode",{parentName:"h5"},"push")),(0,l.kt)("p",null,"The ",(0,l.kt)("inlineCode",{parentName:"p"},"primaryKey")," is added to the ",(0,l.kt)("strong",{parentName:"p"},"end")," of the Group value array."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-ts",metastring:"{2}","{2}":!0},"MY_COLLECTION.collect({id: 1, name: \"jeff\"}, [], {method: 'push'});\nMY_COLLECTION.getGroup(MY_COLLECTION.config.defaultGroupKey).value; // Returns [5, 6, 0, 1]\n")),(0,l.kt)("h5",{id:"unshift-1"},(0,l.kt)("inlineCode",{parentName:"h5"},"unshift")),(0,l.kt)("p",null,"The ",(0,l.kt)("inlineCode",{parentName:"p"},"primaryKey")," is added to the ",(0,l.kt)("strong",{parentName:"p"},"beginning")," of the Group value array."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-ts",metastring:"{2}","{2}":!0},"MY_COLLECTION.collect({id: 8, name: \"jeff\"}, [], {method: 'unshift'});\nMY_COLLECTION.getGroup(MY_COLLECTION.config.defaultGroupKey).value; // Returns [8, 5, 6, 0, 1]\n")),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Default"),(0,l.kt)("th",{parentName:"tr",align:null},"Required"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"push' \\| 'unshift'")),(0,l.kt)("td",{parentName:"tr",align:null},"'push'"),(0,l.kt)("td",{parentName:"tr",align:null},"No")))),(0,l.kt)("br",null),(0,l.kt)("h4",{id:"overwrite-1"},(0,l.kt)("inlineCode",{parentName:"h4"},"overwrite")),(0,l.kt)("p",null,"If ",(0,l.kt)("inlineCode",{parentName:"p"},"true"),", the position of the already existing ",(0,l.kt)("inlineCode",{parentName:"p"},"itemKey"),"\ngets overwritten with the new position of the newly added same ",(0,l.kt)("inlineCode",{parentName:"p"},"itemKey"),"."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-ts"},"const MY_GROUP = MY_COLLECTION.createGroup('group1', [1, 2, 5, 6]);\nMY_GROUP.add(2, {overwrite: true}); // Group value is '[1, 5, 6, 2]'\nMY_GROUP.add(5); // Group value is '[1, 5, 6, 2]'\n")),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Default"),(0,l.kt)("th",{parentName:"tr",align:null},"Required"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"boolean")),(0,l.kt)("td",{parentName:"tr",align:null},"false"),(0,l.kt)("td",{parentName:"tr",align:null},"No")))),(0,l.kt)("br",null),(0,l.kt)("hr",null),(0,l.kt)("br",null),(0,l.kt)("h2",{id:"updateitemkeyconfig"},(0,l.kt)("inlineCode",{parentName:"h2"},"UpdateItemKeyConfig")),(0,l.kt)("p",null,"The ",(0,l.kt)("inlineCode",{parentName:"p"},"UpdateItemKeyConfigInterface")," is used as configuration object in functions like ",(0,l.kt)("a",{parentName:"p",href:"/test/docs/core/collection/methods#updateitemkey"},(0,l.kt)("inlineCode",{parentName:"a"},"updateItemKey()")),".\nHere is a Typescript Interface for quick reference. However,\neach property is explained in more detail below."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-ts"},"export interface UpdateItemKeyConfigInterface {\n    background?: boolean;\n}\n")),(0,l.kt)("br",null),(0,l.kt)("h4",{id:"background-3"},(0,l.kt)("inlineCode",{parentName:"h4"},"background")),(0,l.kt)("p",null,"When ",(0,l.kt)("inlineCode",{parentName:"p"},"true"),", the ",(0,l.kt)("inlineCode",{parentName:"p"},"itemKey")," is updated in ",(0,l.kt)("inlineCode",{parentName:"p"},"background"),"\nand won't cause any rerender on Components that have subscribed the Item or Collection."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-ts",metastring:"{5}","{5}":!0},"// Causes rerender on Components\nMY_COLLECTION.updateItemKey([1, 3]);\n\n// Doesn't cause rerender on Components\nMY_COLLECTION.updateItemKey([1, 3], {background: true});\n")),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Default"),(0,l.kt)("th",{parentName:"tr",align:null},"Required"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"boolean")),(0,l.kt)("td",{parentName:"tr",align:null},"false"),(0,l.kt)("td",{parentName:"tr",align:null},"No")))),(0,l.kt)("br",null),(0,l.kt)("hr",null),(0,l.kt)("br",null),(0,l.kt)("h2",{id:"computeconfig"},(0,l.kt)("inlineCode",{parentName:"h2"},"ComputeConfig")),(0,l.kt)("p",null,"The ",(0,l.kt)("inlineCode",{parentName:"p"},"ComputeConfigInterface")," is used as configuration object in functions like ",(0,l.kt)("a",{parentName:"p",href:"/test/docs/core/computed/methods#compute"},(0,l.kt)("inlineCode",{parentName:"a"},"compute()")),".\nHere is a Typescript Interface for quick reference. However,\neach property is explained in more detail below."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-ts"},"export interface ComputeConfigInterface {\n    autodetect?: boolean;\n}\n")),(0,l.kt)("br",null),(0,l.kt)("h4",{id:"autodetect"},(0,l.kt)("inlineCode",{parentName:"h4"},"autodetect")),(0,l.kt)("p",null,"Tells the ",(0,l.kt)("inlineCode",{parentName:"p"},"Computed Class")," to automatically detect the dependencies (",(0,l.kt)("a",{parentName:"p",href:"/test/docs/introduction/#agile-sub-instance"},"Agile Sub Instances")," used in the ",(0,l.kt)("inlineCode",{parentName:"p"},"computeFunction()"),"."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-ts",metastring:"{2,4}","{2,4}":!0},"MY_COMPUTED.computeFunction = () => MY_NAME.value + MY_AGE.value;\nMY_COMPUTED.recompute({autodetect: false});\nMY_COMPUTED.deps; // Returns '[]'\nMY_COMPUTED.recompute({autodetect: true});\nMY_COMPUTED.deps; // Returns '[Obserrver(MY_NAME), Observer(MY_AGE)]'\n")),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Default"),(0,l.kt)("th",{parentName:"tr",align:null},"Required"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"boolean")),(0,l.kt)("td",{parentName:"tr",align:null},"true"),(0,l.kt)("td",{parentName:"tr",align:null},"No")))),(0,l.kt)("br",null),(0,l.kt)("hr",null),(0,l.kt)("br",null),(0,l.kt)("h2",{id:"recomputeconfig"},(0,l.kt)("inlineCode",{parentName:"h2"},"RecomputeConfig")),(0,l.kt)("p",null,"The ",(0,l.kt)("inlineCode",{parentName:"p"},"RecomputeConfigInterface")," is used as configuration object in functions like ",(0,l.kt)("a",{parentName:"p",href:"/test/docs/core/computed/methods#recompute"},(0,l.kt)("inlineCode",{parentName:"a"},"recompute()")),".\nHere is a Typescript Interface for quick reference. However,\neach property is explained in more detail below."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-ts"},"export interface RecomputeConfigInterface\n    extends StateIngestConfigInterface,\n        ComputeConfigInterface {}\n")),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Note:")," The ",(0,l.kt)("inlineCode",{parentName:"p"},"RecomputeConfig")," extends some other Interfaces:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("a",{parentName:"li",href:"#stateingestconfig"},"StateIngestConfigInterface")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("a",{parentName:"li",href:"#computeconfig"},"ComputeConfigInterface"))),(0,l.kt)("br",null),(0,l.kt)("hr",null),(0,l.kt)("br",null),(0,l.kt)("h2",{id:"updatecomputefunctionconfig"},(0,l.kt)("inlineCode",{parentName:"h2"},"UpdateComputeFunctionConfig")),(0,l.kt)("p",null,"The ",(0,l.kt)("inlineCode",{parentName:"p"},"UpdateComputeFunctionConfigInterface")," is used as configuration object in functions like ",(0,l.kt)("a",{parentName:"p",href:"/test/docs/core/computed/methods#updatecomputefunction"},(0,l.kt)("inlineCode",{parentName:"a"},"updateComputeFunction()")),".\nHere is a Typescript Interface for quick reference. However,\neach property is explained in more detail below."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-ts"},"export interface UpdateComputeFunctionConfigInterface\n    extends RecomputeConfigInterface {\n    overwriteDeps?: boolean;\n}\n")),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"Note:")," The ",(0,l.kt)("inlineCode",{parentName:"p"},"RecomputeConfig")," extends some other Interfaces:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("a",{parentName:"li",href:"#recomputeconfig"},"RecomputeConfigInterface"))),(0,l.kt)("br",null),(0,l.kt)("h4",{id:"overwritedeps"},(0,l.kt)("inlineCode",{parentName:"h4"},"overwriteDeps")),(0,l.kt)("p",null,"Whether the newly defined hard-coded dependencies are merged into the existing ones or overwrite them entirely."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-ts",metastring:"{2,4}","{2,4}":!0},"MY_COMPUTED.deps; // // Returns '[Obserrver(MY_NAME), Observer(MY_AGE)]'\nMY_COMPUTED.updateComputeFunction(() => {}, [MY_LOCATION], {overwriteDeps: false});\nMY_COMPUTED.deps; // // Returns '[Obserrver(MY_NAME), Observer(MY_AGE), Observer(MY_LOCATION)]'\nMY_COMPUTED.updateComputeFunction(() => {}, [MY_LOCATION], {overwriteDeps: true});\nMY_COMPUTED.deps; // // Returns '[Observer(MY_LOCATION)]'\n")),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Default"),(0,l.kt)("th",{parentName:"tr",align:null},"Required"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"boolean")),(0,l.kt)("td",{parentName:"tr",align:null},"true"),(0,l.kt)("td",{parentName:"tr",align:null},"No")))),(0,l.kt)("br",null),(0,l.kt)("hr",null),(0,l.kt)("br",null),(0,l.kt)("h2",{id:"agilehookconfiginterface"},(0,l.kt)("inlineCode",{parentName:"h2"},"AgileHookConfigInterface")),(0,l.kt)("p",null,"The ",(0,l.kt)("inlineCode",{parentName:"p"},"AgileHookConfigInterface")," is used as configuration object in functions like ",(0,l.kt)("a",{parentName:"p",href:"/test/docs/react/hooks#useagile"},(0,l.kt)("inlineCode",{parentName:"a"},"useAgile()")),".\nHere is a Typescript Interface for quick reference. However,\neach property is explained in more detail below."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-ts"},"interface AgileHookConfigInterface {\n  key?: SubscriptionContainerKeyType;\n  agileInstance?: Agile;\n  proxyBased?: boolean;\n}\n")),(0,l.kt)("br",null),(0,l.kt)("h4",{id:"key-3"},(0,l.kt)("inlineCode",{parentName:"h4"},"key")),(0,l.kt)("p",null,"The ",(0,l.kt)("inlineCode",{parentName:"p"},"key/name")," of the ",(0,l.kt)("a",{parentName:"p",href:"/test/docs/core/integration#-subscriptions"},"SubscriptionContainer")," that is created and added to the Observers."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-ts"},"useAgile(MY_STATE, {key: 'jeff'});\n")),(0,l.kt)("p",null,"Such key can be very useful during debug sessions\nin order to analyse when which SubscriptionContainer triggered a rerender on a Component."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-ts"},"// Agile Debug: Registered Callback/Component based Subscription 'jeff', SubscriptionContainer('jeff')\n// Agile Debug: Updated/Rerendered Subscriptions, [SubscriptionContainer('jeff'), ..]\n// Agile Debug: Unregistered Callback/Component based Subscription 'jeff', SubscriptionContainer('jeff')\n")),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Default"),(0,l.kt)("th",{parentName:"tr",align:null},"Required"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"string \\| number")),(0,l.kt)("td",{parentName:"tr",align:null},"undefined"),(0,l.kt)("td",{parentName:"tr",align:null},"No")))),(0,l.kt)("br",null),(0,l.kt)("h4",{id:"agileinstance"},(0,l.kt)("inlineCode",{parentName:"h4"},"agileInstance")),(0,l.kt)("p",null,"The ",(0,l.kt)("a",{parentName:"p",href:"/test/docs/core/agile-instance"},"Agile Instance")," to which the created ",(0,l.kt)("a",{parentName:"p",href:"/test/docs/core/integration#-subscriptions"},"SubscriptionContainer")," belongs to.\nHowever, since each Observer has an instance to the Agile Instance, ",(0,l.kt)("inlineCode",{parentName:"p"},"useAgile()")," can automatically derive the Agile Instance from that."),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Default"),(0,l.kt)("th",{parentName:"tr",align:null},"Required"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("a",{parentName:"td",href:"/test/docs/core/agile-instance"},"Agile Instance")),(0,l.kt)("td",{parentName:"tr",align:null},"undefined"),(0,l.kt)("td",{parentName:"tr",align:null},"No")))),(0,l.kt)("br",null),(0,l.kt)("h4",{id:"proxybased"},(0,l.kt)("inlineCode",{parentName:"h4"},"proxyBased")),(0,l.kt)("p",null,"If the ",(0,l.kt)("inlineCode",{parentName:"p"},"useAgile()")," hook should wrap a ",(0,l.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy"},"Proxy()")," around its return value/s.\nThrough this Proxy, AgileTs is able to track accessed properties of the returned object/s\nand can construct a path to these.\nThe paths allow AgileTs to rerender the Component more efficiently\nby only causing a rerender when an actual accessed property value mutates.\nNormally, the Component is always rerendered on a State change,\nregardless of whether the changed property value is accessed in the Component.\nThis is totally fine if the value is primitive or the whole object is displayed.\nHowever, as soon as we display only a tiny part of the bound State value object,\nthe proxy feature can reduce the rerender count."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-ts"},"const MY_STATE = App.createState({name: 'frank', age: 10})\n\n// -- MyComponent.js ----------------------------------------\n\n// Bind State to 'MyComponent.js'\nconst myState = useAgile(MY_STATE, {proxyBased: true});\n\nreturn <p>{myState.name}</p>\n\n// -- core.js  ----------------------------------------------\n\n// Causes rerender on 'MyComponent.js', \n// since the '.name' property got accessed\nMY_STATE.patch({name: 'jeff'});\n\n// Doesn't cause rerender on 'MyComponent.js', \n// since the '.age' property didn't got accessed\nMY_STATE.patch({age: 20});\n")),(0,l.kt)("p",null,"To avoid having to set the ",(0,l.kt)("inlineCode",{parentName:"p"},"proxyBased")," configuration to ",(0,l.kt)("inlineCode",{parentName:"p"},"true")," every time we use the proxy functionality,\nwe can use the ",(0,l.kt)("a",{parentName:"p",href:"/test/docs/react/hooks#useproxy"},(0,l.kt)("inlineCode",{parentName:"a"},"useProxy()"))," hook which does that part for us."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-ts"},"useProxy(MY_STATE);\n// equal to\nuseAgile(MY_STATE, {proxyBased: true});\n")),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Default"),(0,l.kt)("th",{parentName:"tr",align:null},"Required"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"string \\| number")),(0,l.kt)("td",{parentName:"tr",align:null},"undefined"),(0,l.kt)("td",{parentName:"tr",align:null},"No")))),(0,l.kt)("br",null),(0,l.kt)("hr",null),(0,l.kt)("br",null),(0,l.kt)("h2",{id:"proxyhookconfiginterface"},(0,l.kt)("inlineCode",{parentName:"h2"},"ProxyHookConfigInterface")),(0,l.kt)("p",null,"The ",(0,l.kt)("inlineCode",{parentName:"p"},"ProxyHookConfigInterface")," is used as configuration object in functions like ",(0,l.kt)("a",{parentName:"p",href:"/test/docs/react/hooks#useproxy"},(0,l.kt)("inlineCode",{parentName:"a"},"useProxy()")),".\nHere is a Typescript Interface for quick reference. However,\neach property is explained in more detail below."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-ts"},"interface ProxyHookConfigInterface {\n    key?: SubscriptionContainerKeyType;\n    agileInstance?: Agile;\n}\n")),(0,l.kt)("br",null),(0,l.kt)("h4",{id:"key-4"},(0,l.kt)("inlineCode",{parentName:"h4"},"key")),(0,l.kt)("p",null,"The ",(0,l.kt)("inlineCode",{parentName:"p"},"key/name")," of the ",(0,l.kt)("a",{parentName:"p",href:"/test/docs/core/integration#-subscriptions"},"SubscriptionContainer")," that is created and added to the Observers."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-ts"},"useProxy(MY_STATE, {key: 'jeff'});\n")),(0,l.kt)("p",null,"Such key can be very useful during debug sessions\nin order to analyse when which SubscriptionContainer triggered a rerender on a Component."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-ts"},"// Agile Debug: Registered Callback/Component based Subscription 'jeff', SubscriptionContainer('jeff')\n// Agile Debug: Updated/Rerendered Subscriptions, [SubscriptionContainer('jeff'), ..]\n// Agile Debug: Unregistered Callback/Component based Subscription 'jeff', SubscriptionContainer('jeff')\n")),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Default"),(0,l.kt)("th",{parentName:"tr",align:null},"Required"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"string \\| number")),(0,l.kt)("td",{parentName:"tr",align:null},"undefined"),(0,l.kt)("td",{parentName:"tr",align:null},"No")))),(0,l.kt)("br",null),(0,l.kt)("h4",{id:"agileinstance-1"},(0,l.kt)("inlineCode",{parentName:"h4"},"agileInstance")),(0,l.kt)("p",null,"The ",(0,l.kt)("a",{parentName:"p",href:"/test/docs/core/agile-instance"},"Agile Instance")," to which the created ",(0,l.kt)("a",{parentName:"p",href:"/test/docs/core/integration#-subscriptions"},"SubscriptionContainer")," belongs to.\nHowever, since each Observer has an instance to the Agile Instance, ",(0,l.kt)("inlineCode",{parentName:"p"},"useProxy()")," can automatically derive the Agile Instance from that."),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Default"),(0,l.kt)("th",{parentName:"tr",align:null},"Required"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("a",{parentName:"td",href:"/test/docs/core/agile-instance"},"Agile Instance")),(0,l.kt)("td",{parentName:"tr",align:null},"undefined"),(0,l.kt)("td",{parentName:"tr",align:null},"No")))))}s.isMDXComponent=!0},317:function(e,t,n){"use strict";t.Z=n.p+"assets/images/logger_example-40e90e6c316be5796800c75cb1acd0eb.png"}}]);